#!/usr/bin/env python3
'''
Run from cache/task11:
python -m raggen --trace_file=../cache_replacement/policy_learning/cache/traces/astar_valid.csv
'''

import argparse
import os

import tqdm
from cache import Cache

from cache_replacement.policy_learning.cache.memtrace import MemoryTrace
from cache_replacement.policy_learning.cache.eviction_policy import BeladyScorer, GreedyEvictionPolicy, LRUScorer
from cache_replacement.policy_learning.cache_model.eviction_policy import LearnedScorer
from task02 import model02
from task03 import model03
from task04 import model04



class CacheObserver:
    def __init__(self, multiplier=1):
        self.reset()
        self.num_instructions = 1_000_000_000  # champsim simulates this number of instructions and than crashes
        self.multiplier = multiplier

    def update(self, hit):
        self.cache_hits += int(hit)
        self.cache_accesses += 1

    def reset(self):
        self.cache_accesses = 0
        self.cache_hits = 0

    @property
    def cache_misses(self):
        return self.cache_accesses - self.cache_hits

    def compute_mpki(self):
        return (self.cache_misses * self.multiplier / self.num_instructions) * 1000

    def compute_hit_rate(self):
        return self.cache_hits / self.cache_accesses


def main(args: argparse.Namespace):
    # Determine number of cache accesses
    num_cache_accesses = sum(1 for _ in open(args.trace_file))

    # Cache config
    cache_config = {"cache_line_size": 64, "capacity": 64 * 16 * 64, "associativity": 16}
    model02_config = "task11/model02_config"
    model03_config = "task11/model03_config"
    model04_config = "task11/model04_config"
    # Load memory trace into memory
    # Make sure the trace_file is the 'llm_access_trace.csv' file as generated by champsim
    memtrace = MemoryTrace(args.trace_file, cache_line_size=cache_config["cache_line_size"], max_look_ahead=int(1e5))

    # Initialize observer
    lru_observer = CacheObserver()
    belady_observer = CacheObserver()

    # Initialize models
    t3policy = model03.EvictionPolicyModel.from_config(model02_config)

    # Initialize Belady's optimal eviction policy
    belady_scorer = BeladyScorer(memtrace)
    belady_policy = GreedyEvictionPolicy(belady_scorer)

    lru_scorer = LRUScorer()
    lru_policy = GreedyEvictionPolicy(lru_scorer)

    # Initialize cache
    lru_cache = Cache.from_config(cache_config, eviction_policy=lru_policy)

    assert os.path.exists(args.output_folder), f"Output folder {args.output_folder} does not exist"
    f = open(os.path.join(args.output_folder, args.rag_file), "w")

    # Calculate MPKI and hit rate
    with memtrace:
        for read_idx in tqdm.tqdm(range(num_cache_accesses), desc=f"trace: {args.trace_file}"):
            assert not memtrace.done()
            pc, address = memtrace.next()

            # Clone cache with Belady's optimal eviction policy

            belady_cache = lru_cache.clone(belady_policy)
            lru_hit = lru_cache.read(pc, address)
            lru_observer.update(lru_hit)
            belady_observer.update(belady_cache.read(pc, address))

            if not lru_hit and lru_cache.last_evicted_cache_line is not None:
                lru_evicted_cache_line = lru_cache.last_evicted_cache_line
                belady_evicted_cache_line = belady_cache.last_evicted_cache_line

                f.write(
                    f"PC: {hex(pc)} | LRU Evicted: {hex(lru_evicted_cache_line)} | Belady Evicted: {hex(belady_evicted_cache_line)}\n"
                )

            if read_idx == 10000:
                break
        f.close()

    mpki = lru_observer.compute_mpki()
    hit_rate = lru_observer.compute_hit_rate() * 100
    print(f"From stats: {lru_cache.hit_rate_statistic.success_rate() * 100 }")
    print(f"MPKI: {mpki}, Hit rate: {hit_rate}")


if __name__ == "__main__":

    parser = argparse.ArgumentParser()
    parser.add_argument("--trace_file", type=str, default='cache_replacement/policy_learning/cache/traces/astar_valid.csv')
    parser.add_argument("--output_folder", type=str, default="task11/outputs")
    parser.add_argument("--rag_file", type=str, default="rag_data.txt")
    args = parser.parse_args()

    main(args)
